import Foundation
import PlaygroundSupport

/**
 # Proctocol examples
 
 A standalone Swift playground project to demonstrate basic and advanced protocols
 
 ## Data

 -> See: MockData.md

 ### Features
 
 [F01]: Show a reusable protocol with a common property
 [F02]: Show how default behaviors can be defined and reused.
 [F03]: Show advanced protocol usage — especially associated types and composition.

*/

// MARK: Models

class Company: Hashable, Identifiable, Equatable {
    let id: Int
    var name: String
    var departments: [Department]
    var employees: [Employee] {
        get {
            departments.flatMap { $0.employees }
        }
    }
    
    init(id: Int, name: String, departments: [Department] = []) {
        self.id = id
        self.name = name
        self.departments = departments
    }
        
    func hash(into hasher: inout Hasher) {
        hasher.combine(self.id)
    }
    
    static func == (lhs: Company, rhs: Company) -> Bool {
        return (lhs.id == rhs.id)
    }
}

extension Company: CustomStringConvertible {
    var description: String { return self.name }
}

class Department: Hashable, Identifiable, Equatable {
    let id: Int
    let name: String
    weak var company: Company?
    var employees: [Employee]
    
    init(id: Int, name: String, company: Company, employees: [Employee] = []) {
        self.id = id
        self.name = name
        self.company = company
        self.employees = employees
    }
    
    func hash(into hasher: inout Hasher) {
        hasher.combine(self.id)
    }
    
    static func == (lhs: Department, rhs: Department) -> Bool {
        return (lhs.id == rhs.id)
    }
}

extension Department: CustomStringConvertible {
    var description: String { return self.name }
}

class Employee: Hashable, Identifiable, Equatable {
    let id: Int
    let name: String
    let role: String
    weak var department: Department?
    var sales: [Sale]
    
    init(id: Int, name: String, role: String, department: Department?, sales: [Sale] = []) {
        self.id = id
        self.name = name
        self.role = role
        self.department = department
        self.sales = sales
    }
    
    func hash(into hasher: inout Hasher) {
        hasher.combine(self.id)
    }
    
    static func == (lhs: Employee, rhs: Employee) -> Bool {
        return (lhs.id == rhs.id)
    }
}

extension Employee {
    /// Total sales generated by this employee
    var totalSales: Double {
        sales.reduce(0.0) { $0 + $1.amount }
    }
}

extension Employee: CustomStringConvertible {
    var description: String { return self.name }
}

class Sale: Hashable, Identifiable, Equatable {
    let id: Int
    let amount: Double
    let date: String
    weak var employee: Employee?
    
    init(id: Int, amount: Double, date: String, employee: Employee?) {
        self.id = id
        self.amount = amount
        self.date = date
        self.employee = employee
    }
    
    func hash(into hasher: inout Hasher) {
        hasher.combine(self.id)
    }
    
    static func == (lhs: Sale, rhs: Sale) -> Bool {
        return (lhs.id == rhs.id)
    }
}

// ---

// MARK: Create data

let company = Company(id: 1, name: "Acme Inc", departments: [])

/// Create departments
let departments = [
    Department(id: 1, name: "Sales", company: company, employees: []),
    Department(id: 2, name: "Engineering", company: company,employees: []),
    Department(id: 3, name: "Human Resources", company: company, employees: []),
]

/// Assign the departments to the company
company.departments = departments

/// Make a dictionary mapping a department to its name
let departmentByName = Dictionary(uniqueKeysWithValues: departments.map { ($0.name, $0) })

/// Create employees
let employees = [
    Employee(id: 1, name: "Alice Martin", role: "Sales Manager", department: departmentByName["Sales"], sales: []),
    Employee(id: 2, name: "Bob Sanchez", role: "Software Engineer", department: departmentByName["Engineering"], sales: []),
    Employee(id: 3, name: "Carol White", role: "HR Coordinator", department: departmentByName["Human Resources"], sales: []),
    Employee(id: 4, name: "David Chen", role: "QA Engineer", department: departmentByName["Engineering"], sales: []),
    Employee(id: 5, name: "Eve Summers", role: "Account Executive", department: departmentByName["Sales"], sales: []),
]

/// Make a dictionary mapping an employee by its name
let employeeByName = Dictionary(uniqueKeysWithValues: employees.map { ($0.name, $0) })

/// Create sales
let sales = [
    Sale(id: 1, amount: Double(15000), date: "2024-12-01" , employee: employeeByName["Alice Martin"]), // Alice Martin
    Sale(id: 2, amount: Double(9500), date: "2025-01-15" , employee: employeeByName["Eve Summers"]), // Eve Summers
    Sale(id: 3, amount: Double(12000), date: "2024-12-01" , employee: employeeByName["Alice Martin"]), // Alice Martin
    Sale(id: 4, amount: Double(7500), date: "2025-02-01" , employee: employeeByName["Eve Summers"]), // Eve Summers
    Sale(id: 5, amount: Double(5000), date: "2025-04-05" , employee: employeeByName["Alice Martin"]), // Alice Martin
]

// ---

// MARK: Tie relationships

/// Link employees back to their departments
for employee in employees {
    employee.department?.employees.append(employee)
}

/// Link sales back to their employees
for sale in sales {
    sale.employee?.sales.append(sale)
}




// ---

// MARK: Features

// ---

// [F01]: Show a reusable protocol with a common property, like name.

protocol NameDelegate {
    var name: String { get }
}

/// Add protocols as extensions to existing classes
extension Company: NameDelegate {}
extension Department: NameDelegate {}
extension Employee: NameDelegate {}

/// printNames(of:) that works with any [NameEntity]

func printNames(of entities: [any NameDelegate]) {
    print("Entity Names:")
    for entity in entities {
        print("- \(entity.name)")
    }
}

print ("\n--------------------\n")

// ---

// [F02]: Show how default behaviors can be defined and reused.

///  Protocol with Default Implementation: Salaried
protocol Salaried {
    var baseSalary: Double { get }
    func taxedSalary() -> Double
}

extension Salaried {
    func taxedSalary() -> Double {
        let taxRate = Double(10)
        let result = baseSalary * ((taxRate / 100))
        
        return taxRate
    }
}

extension Employee: Salaried {
    var baseSalary: Double {
        return Double(100)
    }
}

company.employees.forEach { emp in
    print ( "\(emp.name) has a base salary of $\(emp.baseSalary), post-tax: $ \(emp.taxedSalary())" )
}

print ("\n--------------------\n")

// ---

// [F03]: Show advanced protocol usage — especially associated types and composition.

protocol Reportable {}




print ("\n--------------------\n")


// MARK: Exit playground

print("\n\n-- Exiting Playground -- ")
PlaygroundPage.current.finishExecution()

