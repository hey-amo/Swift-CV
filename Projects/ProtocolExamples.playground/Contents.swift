import Foundation
import PlaygroundSupport

/**
 # Proctocol examples
 
 A standalone Swift playground project to demonstrate basic and advanced protocols
 
 ## Data

 -> See: MockData.md

 ### Features
 
 [F01]: Use a reusable, common property (name) across models
 [F02]: Add salaries, taxRate to employees; using protocols
 [F03]: Use a generic report: showing advanced protocol usage, associated types and composition.

*/

// MARK: Models

class Company: Hashable, Identifiable, Equatable {
    let id: Int
    var name: String
    var departments: [Department]
    var employees: [Employee] {
        get {
            departments.flatMap { $0.employees }
        }
    }
    
    init(id: Int, name: String, departments: [Department] = []) {
        self.id = id
        self.name = name
        self.departments = departments
    }
        
    func hash(into hasher: inout Hasher) {
        hasher.combine(self.id)
    }
    
    static func == (lhs: Company, rhs: Company) -> Bool {
        return (lhs.id == rhs.id)
    }
}

extension Company: CustomStringConvertible {
    var description: String { return self.name }
}

class Department: Hashable, Identifiable, Equatable {
    let id: Int
    let name: String
    weak var company: Company?
    var employees: [Employee]
    
    init(id: Int, name: String, company: Company, employees: [Employee] = []) {
        self.id = id
        self.name = name
        self.company = company
        self.employees = employees
    }
    
    func hash(into hasher: inout Hasher) {
        hasher.combine(self.id)
    }
    
    static func == (lhs: Department, rhs: Department) -> Bool {
        return (lhs.id == rhs.id)
    }
}

extension Department: CustomStringConvertible {
    var description: String { return self.name }
}

class Employee: Hashable, Identifiable, Equatable {
    let id: Int
    let name: String
    let role: String
    weak var department: Department?
    var sales: [Sale]
    
    init(id: Int, name: String, role: String, department: Department?, sales: [Sale] = []) {
        self.id = id
        self.name = name
        self.role = role
        self.department = department
        self.sales = sales
    }
    
    func hash(into hasher: inout Hasher) {
        hasher.combine(self.id)
    }
    
    static func == (lhs: Employee, rhs: Employee) -> Bool {
        return (lhs.id == rhs.id)
    }
}

extension Employee {
    /// Total sales generated by this employee
    var totalSales: Double {
        sales.reduce(0.0) { $0 + $1.amount }
    }
}

extension Employee: CustomStringConvertible {
    var description: String { return self.name }
}

class Sale: Hashable, Identifiable, Equatable {
    let id: Int
    let amount: Double
    let date: String
    weak var employee: Employee?
    
    init(id: Int, amount: Double, date: String, employee: Employee?) {
        self.id = id
        self.amount = amount
        self.date = date
        self.employee = employee
    }
    
    func hash(into hasher: inout Hasher) {
        hasher.combine(self.id)
    }
    
    static func == (lhs: Sale, rhs: Sale) -> Bool {
        return (lhs.id == rhs.id)
    }
}

// ---

// MARK: Create data

let company = Company(id: 1, name: "Acme Inc", departments: [])

/// Create departments
let departments = [
    Department(id: 1, name: "Sales", company: company, employees: []),
    Department(id: 2, name: "Engineering", company: company,employees: []),
    Department(id: 3, name: "Human Resources", company: company, employees: []),
]

/// Assign the departments to the company
company.departments = departments

/// Make a dictionary mapping a department to its name
let departmentByName = Dictionary(uniqueKeysWithValues: departments.map { ($0.name, $0) })

/// Create employees
let employees = [
    Employee(id: 1, name: "Alice Martin", role: "Sales Manager", department: departmentByName["Sales"], sales: []),
    Employee(id: 2, name: "Bob Sanchez", role: "Software Engineer", department: departmentByName["Engineering"], sales: []),
    Employee(id: 3, name: "Carol White", role: "HR Coordinator", department: departmentByName["Human Resources"], sales: []),
    Employee(id: 4, name: "David Chen", role: "QA Engineer", department: departmentByName["Engineering"], sales: []),
    Employee(id: 5, name: "Eve Summers", role: "Account Executive", department: departmentByName["Sales"], sales: []),
]

/// Make a dictionary mapping an employee by its name
let employeeByName = Dictionary(uniqueKeysWithValues: employees.map { ($0.name, $0) })

/// Create sales
let sales = [
    Sale(id: 1, amount: Double(15000), date: "2024-12-01" , employee: employeeByName["Alice Martin"]), // Alice Martin
    Sale(id: 2, amount: Double(9500), date: "2025-01-15" , employee: employeeByName["Eve Summers"]), // Eve Summers
    Sale(id: 3, amount: Double(12000), date: "2024-12-01" , employee: employeeByName["Alice Martin"]), // Alice Martin
    Sale(id: 4, amount: Double(7500), date: "2025-02-01" , employee: employeeByName["Eve Summers"]), // Eve Summers
    Sale(id: 5, amount: Double(5000), date: "2025-04-05" , employee: employeeByName["Alice Martin"]), // Alice Martin
]

// ---

// MARK: Tie relationships

/// Link employees back to their departments
for employee in employees {
    employee.department?.employees.append(employee)
}

/// Link sales back to their employees
for sale in sales {
    sale.employee?.sales.append(sale)
}

// MARK: Helpers

struct FormatterCache {
    static let currency: NumberFormatter = {
        let formatter = NumberFormatter()
        formatter.locale = Locale(identifier: "en_US")
        formatter.numberStyle = .currency
        formatter.minimumFractionDigits = 0
        formatter.maximumFractionDigits = 0
        formatter.allowsFloats = false
        formatter.roundingMode = .ceiling
        formatter.alwaysShowsDecimalSeparator = false
        return formatter
    }()
}

extension Double {
    var formattedAsCurrency: String {
        return FormatterCache.currency.string(from: NSNumber(value: self)) ?? "$???"
    }
}


// ---

// MARK: Features implementation

// ---

// [F01]: Use a reusable, common property (name) across models

protocol NameDelegate {
    var name: String { get }
}

/// Add protocols as extensions to existing classes
extension Company: NameDelegate {}
extension Department: NameDelegate {}
extension Employee: NameDelegate {}

/// printNames(of:) that works with any [NameEntity]

func printNames(of entities: [any NameDelegate]) {
    print("Entity Names:")
    for entity in entities {
        print("- \(entity.name)")
    }
}

print ("\n--------------------\n")

// ---

// [F02]: Add salaries, taxRate to employees; using protocols

///  Protocol with Default Implementation: Salaried
protocol Salaried {
    var baseSalary: Double { get }
    func taxedSalary(taxRate: Double) -> Double
}

extension Salaried {
    func taxedSalary(taxRate: Double) -> Double {
        let tax = baseSalary * (taxRate / 100)
        let net = (baseSalary - tax)
        return Double(net)
    }
}

/// Currently, each `employee` has the same salary; so lets implement a different salary per department, and add an extension to `employee` of departmentType

extension Employee {
    var departmentType: DepartmentType? {
        switch department?.name.lowercased() {
        case "sales": return .sales
        case "engineering": return .engineering
        case "human resources": return .hr
        default: return nil
        }
    }
}

enum DepartmentType {
    case sales, engineering, hr
}
extension Employee: Salaried {
    var baseSalary: Double {
        switch departmentType {
        case .sales: return 80_000
        case .engineering: return 95_000
        case .hr: return 70_000
        default: return 60_000
        }
    }
}

/// Create a random tax rate between 1-10% for demo purposes
let taxRate = Double(Int.random(in: 1...10))

/// Print out the employee with base salary, tax rate, net tax
print ("Employees, base salary, tax and net-tax:\n")
company.departments
    .flatMap { $0.employees }
    .forEach { emp in
        let tax = emp.baseSalary * (taxRate / 100)
        let net = emp.baseSalary - tax
        
        print("\(emp.name): Base \(emp.baseSalary.formattedAsCurrency), Tax \(tax.formattedAsCurrency), Net \(net.formattedAsCurrency)")
}

print ("\n--------------------\n")

// ---

// [F03]: Use a generic report: showing advanced protocol usage, associated types and composition.

protocol Reportable {
    associatedtype DataType
    var title: String { get }
    var data: [DataType] { get }
    func format(_ item: DataType) -> String
}

struct Reporter<T: Reportable> {
    let report: T

    func printReport() {
        print("ðŸ“„ Report: \(report.title)")
        report.data.forEach { print(report.format($0)) }
    }
}

extension Employee: Reportable {
    var data: [String] {
        return ["one", "two", "three"]
    }
    
    typealias DataType = String
    
    var title: String {
        return "Salary"
    }
    func format(_ item: String) -> String {
        return item
    }
}



print ("\n--------------------\n")


// MARK: Exit playground

print("\n\n-- Exiting Playground -- ")
PlaygroundPage.current.finishExecution()

